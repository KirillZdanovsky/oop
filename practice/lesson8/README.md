[Назад к описанию](../../README.md)

# Порождающие шаблоны: "Одиночка" и "Объектный пул". Принципы SOLID

Содержание:
- [Шаблон "Одиночка"](#Шаблон-Одиночка)
- [Шаблон "Объектный пул"](#Шаблон-Объектный-пул)
- [Принципы `SOLID`](#Принципы-SOLID)
  - [Принцип единственной ответственности](#Принцип-единственной-ответственности)
  - [Принцип открытости/закрытости](#Принцип-открытостизакрытости)
  - [Принцип подстановки Барбары Лисков](#Принцип-подстановки-Барбары-Лисков)
  - [Принцип разделения интерфейса](#Принцип-разделения-интерфейса)
  - [Принцип инверсии зависимостей](#Принцип-инверсии-зависимостей)

## Шаблон "Одиночка"

Шаблон "Одиночка" (порождающий шаблон) гарантирует, что для определенного класса будет создан только один объект, а также предоставляет к этому объекту точку доступа.

Формальное определение шаблона на `C++`:

```c++
// Синглтон Майерса.
class Singleton
{
public:
  static Singleton &Instance()
  {
    static Singleton instance;
    return instance;
  }

private:
  // Убираем возможность создания экземпляров класса.
  Singleton(){};
  Singleton(const Singleton &root) = delete;
  Singleton &operator=(const Singleton &) = delete;
};
```

## Шаблон "Объектный пул"

Шаблон "Объектный пул" (порождающий шаблон) предназначен для создания набора инициализированных и готовых к использованию объектов. Когда системе требуется объект, он не создаётся, а берётся из пула. Когда объект больше не нужен, он не уничтожается, а возвращается в пул.

Формальное определение шаблона на `C++`:

```c++
#include <vector>

using namespace std;

template <class T>
class Pool
{
private:
  struct Record
  {
    T *instance;
    bool used;
  };

  vector<Record> pool;

public:
  T *createNewObject()
  {
    for (size_t i = 0; i < pool.size(); ++i)
    {
      // Ищем свободный объект.
      if (!pool[i].used)
      {
        pool[i].used = true;
        return pool[i].instance;
      }
    }

    // Если свободного объекта нет, то создаём новый.
    Record record;
    record.instance = new T;
    record.used = true;

    pool.push_back(record);

    return record.instance;
  }

  // Указываем, что объект теперь свободен (а не удаляем его).
  void deleteObject(T *object)
  {
    for (size_t i = 0; i < pool.size(); ++i)
    {
      if (pool[i].instance == object)
      {
        pool[i].used = false;
        break;
      }
    }
  }

  // Реальное удаление объектов происходит в деструкторе.
  virtual ~Pool()
  {
    for (size_t i = 0; i < pool.size(); ++i)
      delete pool[i].instance;
  }
};
```

## Принципы `SOLID`

Принципы `SOLID`:
- `The Single Responsibility Principle` (Принцип единственной ответственности),
- `The Open/Closed Principle` (Принцип открытости/закрытости),
- `The Liskov Substitution Principle` (Принцип подстановки Барбары Лисков),
- `The Interface Segregation Principle` (Принцип разделения интерфейса),
- `The Dependency Inversion Principle` (Принцип инверсии зависимостей).

Признаки плохого проекта:
- `закрепощённость`: система с трудом поддается изменениям, поскольку любое минимальное изменение вызывает эффект "снежного кома", затрагивающего другие компоненты системы,
- `неустойчивость`: в результате осуществляемых изменений система разрушается в тех местах, которые не имеют прямого отношения к непосредственно изменяемому компоненту,
- `неподвижность`: достаточно трудно разделить систему на компоненты, которые могли бы повторно использоваться в других системах,
- `вязкость`: сделать что-то правильно намного сложнее, чем выполнить какие-либо некорректные действия.
- `неоправданная сложность`: проект включает инфраструктуру, применение которой не влечёт непосредственной выгоды,
- `неопределенность`: проект трудно читать и понимать. Недостаточно четко выражено содержимое проекта.

### Принцип единственной ответственности

Формулировка:

> У класса должна быть только одна причина для изменения.

Каждый объект должен иметь одну ответственность и эта ответственность должна быть полностью инкапсулирована в класс. Все его поведения должны быть направлены исключительно на обеспечение этой ответственности.

Проверяем, сколько у нас есть причин для изменения класса — если больше одной, то следует разбить данный класс.

### Принцип открытости/закрытости

Формулировка:

> Сущности программы должны быть открыты для расширения, но закрыты для изменения.

Система должна быть построена таким образом, что все ее последующие изменения должны быть реализованы с помощью добавления нового кода, а не изменения уже существующего.

Представляем наш класс как «чёрный ящик» и смотрим, можем ли в таком случае изменить его поведение.

### Принцип подстановки Барбары Лисков

Формулировка:

> Должна быть возможность вместо базового типа подставить любой его подтип.

Поведение наследуемых классов не должно противоречить поведению, заданному базовым классом, то есть поведение наследуемых классов должно быть ожидаемым для кода, использующего переменную базового типа.

Должны быть соблюдены следующие правила:
- предусловия (то, что должно быть выполнено вызывающей стороной перед вызовом метода) не могут быть усилены в подклассе,
- постусловия (то, что гарантируется вызываемым методом) не могут быть ослаблены в подклассе,
- инварианты (некоторые условия, которые остаются истинными на протяжении всей жизни объекта) должны быть сохранены и в подклассе.

Проверяем, не усилили ли мы предусловия и не ослабили ли постусловия. Если это произошло — то принцип не соблюдается

### Принцип разделения интерфейса

Формулировка:

> Клиенты не должны вынужденно зависеть от методов, которыми не пользуются.

Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

Проверяем, насколько много интерфейс содержит методов и насколько разные функции накладываются на эти методы, и если необходимо — разбиваем интерфейсы.

### Принцип инверсии зависимостей

Формулировка:

> Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Проверяем, зависят ли классы от каких-то других классов(непосредственно инстанцируют объекты других классов и т.д) и если эта зависимость имеет место, заменяем на зависимость от абстракции.